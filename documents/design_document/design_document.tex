%% The comment character in TeX / LaTeX is the percent character.
%% The following chunk is called the header

\documentclass{article}	% essential first line
\usepackage{times}		% this uses fonts which will look nice in PDF format
\usepackage{graphicx}		% needed for the figures
\usepackage{url}
\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{multicol}
\usepackage{color}
\usepackage{multirow}
\usepackage{array}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{hyperref}

%% Set the folder where pictures are located
\graphicspath{ {pi_images/} {images/} {../poster/images/} }

%% Here I adjust the margins

\oddsidemargin -0.5in%-0.25in		% Left margin is 1in + this value
\textwidth 7.5in		% Right margin is not set explicitly
\topmargin 0in			% Top margin is 1in + this value
\textheight 9in			% Bottom margin is not set explicitly
\columnsep -0.25in %0.25in		% separation between columns

% vplace enviornment
\newenvironment{vplace}[1][1]
  {\par\vspace*{\stretch{#1}}}
  {\vspace*{\stretch{1}}\par}

% set listing settings
\lstset{language=C, 
		numbers=left,
		frame=single,
		tabsize=2,
		breaklines=true,
		commentstyle=\color{red}}

%% Define the fields to be displayed by a \maketitle command
\author{Dee, Timothy\\
    \texttt{timdee@iastate.edu}
    \and
    Long, Justin\\
    \texttt{jwlong@iastate.edu}
    \and
    McDonnell, Brandon\\
    \texttt{bmm@iastate.edu}
}

\title{Remotely Connected Electric Field Generator\\
for Particle Separation in a Fluid \\
\large{Team May1612}}

%%
%% Header now finished
%%

\begin{document}

%\begin{vplace}[0.7]
\thispagestyle{empty}
\maketitle
%\end{vplace}

\newpage
\tableofcontents
\newpage

\begin{multicols}{2}

\abstract{
This document details the design and implementation of a
remotely controlled electric field generator.
The goal of this design is to provide an easy interface for
manipulating the output voltage and frequency of a circuit
utilizing network communications in order to generate an electric field.
This electric field,
when applied to a fluid over a long period of time
will cause particles in the fluid to separate.
The hardware and software components used to accomplish
the aforementioned goal are described in detail as well as
the interconnections between these components.
A guide describing the procedure by which a person may
set up and use this implementation is provided.
}

% Make an argument for why this project is:
% useful
% necessary
% novel
\section{Introduction}
New research has shown that certain particles may be separated from fluids through dielectrophoresis.
This process involves applying an electric field to a fluid.
The field may be manipulated in order to attract or repel certain particles.
The particles the electric field will attract or repel depends on
characteristics of the electric filed which may be controlled
by varying the voltage and frequency of the electronics driving the field.

This technology has many useful applications in health care.
The proposed end use of this equipment is
for separating particles contained in bodily fluids,
such as spinal fluid.
Such medial applications could be useful
in filtering these fluids for testing purposes.

Being capable of separating though the
application of an electric field would represent
an advancement over existing solutions.
Separation in this way introduces a new method of testing which
could be more precise when compared
to existing technologies.

Imagine if a centrifuge, an expensive piece of medical testing equipment which
separates particles in bodily fluids, 
could be replaced by a
much cheaper device.
This cheaper device could even have the potential for
more well-defined separation among particles.
Such a device, if it could be made to exist,
would have large, positive, economic consequences for creator.
This project could construct the foundation for
such a device.

% describe how dielectrophoresis works
This project is part of a larger initiative to build a device
which is capable of separating particles in fluids
utilizing the dielectrophoresis phenomenon.
This phenomenon works though the
application of a quickly changing electric field.
The change in the electric field affects
different types of particles differently leading
to a separation among types of particles.
This process must continue for a long period of time
in order for a great degree of separation to occur.
Often times this process can take hours.

% TODO spend more time telling a story and developing a need

\section{Project Definition}
In this implementation, an electric field is applied 
to two metal plates.
Through varying the voltage and frequency
applied to these plates, 
the properties of the electric field may be changed.
Modifying the properties of the electric field will
affect separation of fluids and
is therefore desirable.

Our job is to construct a system 
containing an electronic circuit capable of providing
the voltages and frequencies required 
to drive a pair of metal plates.
This system must enable the circuit to be controllable 
through the use of a web interface.
In addition, a small form factor must be maintained.

The system must be able to generate up to a 60 V peak-peak sine wave with
user-controlled variable frequency from 10 kHz to 1 MHz. 
Due to the time requirements of dielectrophoresis,
this output must also be capable of being maintained for long periods of time.
In addition,
the user of this system should be capable of controlling it
remotely.
The implications of this on the implementation are that
there must be some way of 
communicating with the device through a network.

\subsection{Deliverables}
There are three items which must be constructed for this project:
frequency control circuit,
voltage control circuit, and
software components.
% TODO list the components which must be constructed

For the analog circuit components,
functionality of the circuit will be tested
using an oscilloscope to verify 
the requirements have been satisfied.
This method can also be used to ensure 
the output signal contains minimal amounts of noise and distortion. 

% TODO if we don't get to the research component of the project,
% we should remove this
The construction of this device is the first phase of the project.
After the completion of this component,
the device will be used 
to experiment with particle separation in various fluid types.
These experiments constitute the remainder of the project.
% TODO add adam's name
For these experiments our advisor at Minetronix, John Pritchard, 
will be the main source of guidance and testable material. 

\subsection{Constraints}
Constraints on this project fall within the size, voltage, and portability domains.

The size requirements of this project are directly related 
to the portability of the final design.
The design requirements specify this system must be easily and quickly
moved around from one workstation to another.
The maximal allowed size is approximately 
the size of a backpack 
with smaller sizes being more desirable
but not explicitly required.
With the electronics currently being used,
these requirements will easily be met.

Another constraint arises from the power supply requirements.
The power supply must deliver at least 60V DC in order to feed the amplifier circuit. 
Due to this, the final design requires a power brick
similar to one which would be used to charge a laptop.
Importantly, this would require the device to be plugged into a wall outlet.
This is not seen as an issue.
Every location this device will operate 
will most likely have other equipment with similar power requirements.

In order to use this system,
there are other items which are required
apart from the device itself. 
The first requirement is a network connection between the device and a computer.
This connection is necessary to be able to interact with the web server hosted on the Raspberry Pi. 
Without a computer to interact with this system there is no practical means of utilizing the device's functionality. 
The next requirement, as mentioned above, is a network connection to the Raspberry Pi. 
The third system requirement is a standard wall outlet
to accommodate the power needs of the system. 

\subsection{System Analysis}
A user will interface with this system though the web interface.
This web interface may be accessed by
typing the IP address of the device into a standard web browser.
The interface will allow the user to choose the values for Voltage and Frequency.
Once these values have been entered,
update scripts on the Raspberry Pi
will set the voltage and frequency output of the circuit
according to the values entered.

%\section{Block Diagram}
\begin{figure*}[!hbt]
\begin{center}
\includegraphics[width=1.0\textwidth,keepaspectratio]{block_diagram.png}
\end{center}
\caption{Block Diagram provides an overview of the system components.}
\end{figure*}

\section{Functional Decomposition}
This system has four fundamental functional blocks.
These include the 
Web Interface, 
Raspberry Pi, 
Minigen Signal Generator, and
Amplifier Circuit.
The project will be described in terms of 
these components and
their interactions.

\subsection{Raspberry Pi}
The Raspberry Pi will act as the bridge between the user and the circuit.
The Raspberry Pi will host a web server allowing the user to interact with the system.
Based on the results of this user interaction, 
the Raspberry Pi will update the state of the GPIO pins.
The GPIO pins connect to a circuit causing the output to change based on their state. 

In addition to hosting the web server the Raspberry pi is used to
communicate with the 
Minigen Signal Generator and 
amplifier circuit.
This communication is accomplished via 
the Raspberry Pi's SPI interface and
GPIO pins respectively.

% the reason a raspberry pi was chosen
There are many potential solutions other than 
the Raspberry Pi.
So what motivated the choice of the Raspberry Pi?
The answer is as would expected,
the Raspberry Pi has capabilities which allow it
to act as a communicator between 
the user and the circuit.
While other devices have similar capabilities,
such as an Arduino,
the requirement of having a web interface is a
lot easier to implement on the pi compared to
most Arduinos.

Another factor consistent with the goals
of the project is the small form factor
of the Raspberry pi.
While there was no exact specification,
it was made clear that smaller implementations
are preferred.
On top of the above mentioned factors
the Raspberry Pi is also inexpensive.
Given all of these factors,
the Raspberry Pi seems like an ideal
fit for this project.

% insert Raspberry Pi connection diagram
\begin{center}
\includegraphics[width=0.43\textwidth,keepaspectratio]{rpi_real.png}
\end{center}

\subsection{Minigen}
The Minigen Function Generator device controls the frequency output by the circuit.
Varying the frequency is accomplished 
by writing to registers present on the Minigen.
This communication is completed over SPI between
the Raspberry Pi and the Minigen.
The frequency produced is a function of
the values contained in the Minigen's frequency registers.

The Minigen outputs a waveform 
from -0.5V to 0.5V. 
This waveform may be a triangle, square, or sine wave.
The voltage output by the Minigen is not variable.
Given that the design specification requires a variable voltage,
the voltage needs to be adjusted separately.
Accordingly, the output of the Minigen 
is supplied to the input of the amplifier circuit.

The Minigen is controlled by setting five registers,
two registers for frequency, 
two for phase shift and 
one as a control. 
There exists no need for phase shifting
to meet the design requirements, 
however the frequency and control registers
are needed. 
By having two frequency registers,
data can be sent to one register while it is not in use,
followed by a write to the control register to use this register.
This allows for a nicer gradient, 
because the frequency will not change until the entire frequency register is written. 
The control register also allows for changing between sine, square and triangle waveforms.
In the event that the frequency needs to be finely adjusted,
this system utilizes the functionality of the control register
to modify the way in which writes to the frequency registers are received.
The way writes are received by the frequency registers 
can be varied between two modes.
In one mode,
two consecutive 14-bit writes to a frequency register are used.
In the other mode,
one write to the lower 14-bits of the 28-bit frequency register is used.
This functionality affords the ability to accurately dial in small changes to the register values quickly.

\begin{center}
\includegraphics[width=0.43\textwidth,keepaspectratio]{minigen_real.png}
\end{center}

Until this point,
several functional benefits of the Minigen Signal Generator have been discussed.
An additional benefit which 
increases the practicality of this solution is the Minigen's small form factor.
The small chip size 
allows the Minigen to fit easily into a small case 
with the Raspberry Pi.
This is consistent with the system's requisite small footprint.

\subsection{Amplifier Circuit}
As mentioned in the previous section,
the output of the Minigen Function Generator
is applied to the amplifier circuit as input.
The amplifier also receives input from 
the GPIO pins of the Raspberry Pi.
These GPIO pins act as switches which help to control the output voltage.
Based on these inputs 
the amplifier circuit manages the overall 
voltage and frequency output.

The project requirements state that the system must 
generate signals which range from $1V_{pp}$ to $60V_{pp}$. 
To accomplish this,
various circuit components were used to accomplish the amplification.
The overall scheme is to split the output voltages into
three different ranges.
One component is used to adjust the voltage within each of the ranges while
other comp are used to change the range the voltage adjuster is acting within.

A schematic illustrating the amplifier circuit as a whole is 
depicted in Figure \ref{figure_amplifier_circuit}.
This diagram follows the signal from
the output of the Minigen Function Generator to
the overall output of the circuit after the summing amplifier.
The Minigen output feeds directly into two stages of amplification.
Each stage containing a PGA and an amplifier.
The upper stage in the diagram contains a gain of 7.5 while
the lower stage contains a gain of 1.

The lower stage has many more components than the top stage.
The reason for this is the OPA552 operational amplifier which is
being used to preform the amplification,
is optimized for a gain of five or more.
For gains lower than five,
there must be additional components added.
The effect of not adding these components is a dramatic
increase in the frequency of the output.

\begin{figure*}[!hbt]
\begin{center}
\includegraphics[width=0.8\textwidth,keepaspectratio]{circuit_diagram.pdf}
\end{center}
\caption{Amplifier circuit design to vary voltage 
    within range $1V_{pp}$ to $60V_{pp}$. }
\label{figure_amplifier_circuit}
\end{figure*}

\subsubsection{Programmable Gain Amplifier(PGA)}
The programmable gain amplifier or PGA is 
core mechanism by which voltage is modified in the circuit.
As can be seen in the circuit diagram \ref{figure_amplifier_circuit},
There are two PGA's utilized in the circuit.
Each PGA controls one stage of amplification.
The PGA has 8 possible output gains, 0-7.
These gains are set though the use of three GPIO pins.
Each GPIO pin is connected to one input pin on the PGA.
The gain of the pga is selected by the binary number encoded by 
these bits.

\subsubsection{Amplification Stages}
There are two amplification stages pictured in
Figure \ref{figure_amplifier_circuit}.
Each of these stages takes input from the Minigen.
The first component in each stage, the PGA,
takes this input,
applies a gain $K$ in range $0 to 7$, then
inputs this signal to an OPA552 operational amplifier.
These amplifiers output to the input of the summing amplifier.

The gain, $A$, of these amplifiers after the PGA's are chosen
to maximize the voltage resolution.
The overall voltage requirement is the circuit must output $1 to 60V_{pp}$.
In order for the output of the summing amplifier,
which follows the amplification stages,
to be capable of outputting $60V_{pp}$ the output of all voltage
stages must sum to this value.

% voltage stage amplification computation
\begin{gather*}
A_1 = gain of stage 1 amp\\ 
A_2 = gain of stage 2 amp\\
A_{PGA} = max gain of PGA\\
V_{m1} = max voltage of stage 1\\
V_{m2} = max voltage of stage 2\\
V_{m1} + V_{m2} = 30V\\
V_{m1} = \frac{V_{m2}}{7}\\
V_{m1} + 7V_{m1} = 30V\\
8V_{m1} = 30V\\
V_{m1} = \frac{30V}{8}\\
V_{m1} = 3.75V\\
V_{m2} = 26.25V\\
A_{PGA} = 3.5V\\
A_1 = \frac{V_{m1}}{A_{PGA}} = \frac{V_{m1}}{3.5}\\
A_2 = \frac{V_{m2}}{A_{PGA}} = \frac{V_{m2}}{3.5}\\
A_1 = 1.07\frac{V}{V}\\
A_2 = 7.5\frac{V}{V}\\
\end{gather*}

The above equation derives the appropriate
gain for the amplifier in both stages
of the circuit.
These Gains $A_1$ and $A_2$ represent these gains.
Notice that one of the gains is greater than
5 while the other has a gain close to unity.
This is an issue for us because the op-amp,
OPA552, which we are using in our circuit is 
optimized for a gain of 5 or greater.

If the gain is under 5 additional components
are necessary to make the op-amp stable.
Unfortunately these components have two negate affects.
First, these components act as a filter.
Second, there components apply a phase shift to the output.
This increases the complexity of the circuit.
There must be some additional components added
to ensure the phase shift of both amplification stages are the same.

% discuss the complexity associated with making the phase shifts the same
% potentially list the transfer function of a single amplifier?
\begin{center}
\includegraphics[width=0.43\textwidth,keepaspectratio]{gain_one_552.pdf}
gain of 1 op-amp with\\ frequency compensation and phase shift correction.
\end{center}

There are two amplification stages.
Due to the frequency compensation necessary one one stage,
the phase shifts of these stages were initially different.
In order to make the phase shits the same,
a resistor in series with a capacitor to ground were applied
to both the input and output of the frequency compensation amplifier.
The end result is that we are able to modify the phase shift according
to this transfer function:
\begin{gather*}
\frac{V_{out}}{V_{in}} = \frac{-R_f}{(-j * \omega * C_{12} * R_{12} + 1)*(j * \omega * C_f * R_f + 1)*R_1}
\end{gather*}

This function allowed us to predict the phase shift amount for a given frequency.
This knowledge allowed the modification of the values to reproduce the
phase shift present in the other stage.

\subsubsection{Summing Amplifier}
The summing amplifier is the last component
in the amplifier circuit.
The overall voltage range which needs to be produced is divided into two segments.
Each of these segments have their output connected as
input to the summing amplifier.
The advantage of this design is that
it allows for an increased number of voltage steps
compared to what is allowed for by a single PGA.

The output of the summing amplifier conforms to
the above equation.
As can be seen in this listing,
the amplifier will take take the input signals
and sum them.
If, for example, 
the input voltages are $3V$ and $10V$, the
output will be $13V$.

The negative effects of choosing to 
implement the summing in this way is
that large constraints are placed on the amplifier.
The summing amplifier will need to be capable
of producing a sine wave at $60V_{pp}$ and $1M_{hz}$.
This means the slew rate of this op-amp will need to be
$120 \frac{V}{\mu s}$.
These constraints are fairly limiting and require
an expensive op-amp to meet.

\section{Software Components}
The web interface displayed by
the web server hosted on the Raspberry Pi
is the user's window into the system.
Through this interface,
the user can seamlessly control various
components of the system cause 
the desired voltage and frequency 
to be produced.
Previously covered are
the hardware components used to accomplish this.
This section describes the software counterparts
used to control the hardware.

% justify all technology choices
\subsection{Technology Choices}
There are many tools to accomplish any job.
In the software domain there are many utilities
and programming languages which could have been
used to accomplish the goals set forth in this project description.
Why then did were apache 2 and python chosen?
What could be the advantage of using these software tools over others?
This section seeks to answer the aforementioned questions.

% apache 2
Apache 2 was chosen as our web server due
to it's ease of installation and use,
good documentation, and
large user base.
In some respects,
Apache 2 is often the default choice for web server applications.
Only if there are special or advanced features necessary,
which are not available by utilizing Apache 2 would there
been consideration for other applications.
Apache 2 is a very well known web server implementation with a lot of users.
Any foreseeable problem for this project will likely have
information available from other people having faced the same or similar problem.

% python
Python is a powerful scripting language which
is designed around the ideals of quick and pretty code.
That is, 
the goal of Python's creators was to write a language
which would be easily readable, quick to write, and
have a lot of functionality.
For this project,
time is of the essence.
Any intelligent choice of tool which will help to speed the process of 
completing one aspect of the project will allow more time to be spent on another.
Python also has many useful libraries such as spidev and RPi.GPIO
which were used in this project.
The relative ease of programming in combination with the useful and
relevant libraries made Python the clear choice for this project.

\subsection{Web Interface}
The web interface is hosted on the Raspberry Pi using an Apache web server.
This web server displays an interface which allows the user to
set a voltage and frequency output by the system. 
The interface is simple and interactive,
implemented using cgi-scripts on the Apache web server.

Our implementation provides several functionalities.
Among these are
the ability to set:
voltage and frequency,
sine or triangle or square waveforms,
and the ability to set a voltage and frequency for an amount of time.
The table displayed
in the figure below
provides the ability to set voltage and frequency for the number
of minutes specified.
The "Go" button will cause the first
voltage and frequency to be set for the corresponding amount of time.
After the time has expired,
the next voltage and frequency will be set for the corresponding amount of time.
This process continues until the table entries are completed or
the user presses the "Stop" button.

\begin{center}
\includegraphics[width=0.43\textwidth,keepaspectratio]{web_interface.pdf}
\end{center}

\subsection{Web Server}
The primary function of the web server is to communicate with the Raspberry Pi.
This is the primary method of control afforded 
to the user by the system. 
The web pages displayed by the server
have the ability to control the voltage and frequency output by the circuit.

Displaying this interface is accomplished by 
running an Apache web server on the Raspberry Pi. 
When the user clicks update, the server could executes 
a cgi-script performing the update functionality.

% code layout diagram
%\begin{figure}[!hbt]
\begin{center}
\includegraphics[width=0.43\textwidth,keepaspectratio]{script_layout.pdf}
\end{center}
%\caption{Script layout according to work delegation.}
%\label{fig_script_layout}
%\end{figure}

\subsection{Modifying Frequency}
The frequency output by the circuit is controlled 
by the Minigen Function Generator.
Thus the software components used to 
modify the output frequency
are in essence
a method of communication with the Minigen device.

The process begins when the user 
enters a new frequency value into the web interface
and clicks the "update" button.
The \textit{update.py} script parses 
the parameters contained in the URL
resulting from the user's update request.
These parameters are than
passed on to \textit{update\_voltage\_frequency.py}
which determines the appropriate update procedure 
with which to call \textit{minigen.py}.

% explain how minigen.py works in detail
\textit{minigen.py} is a script,
written in python and uses the spidev library
to communicate with the Minigen.
This communication is tricky due
to the layout of the registers on the Minigen.
There are five registers:
two frequency registers,
two phase registers, and
one control register.
A combination of these registers
need to be written to cause the Minigen to produce the correct output.

Take the typical use case for this project of
modifying the frequency.
There are two frequency registers.
Only one of these are active at a time;
active defined as the output of the Minigen being derived from that register.
The control register must be written in order to change the active register.
Further complicating this process is that the frequency registers are
28 bits wide, but the Minigen only accepts 16 bit writes at a time over SPI.
In addition, there are two modes in which frequency can be written
depending on the settings of the control register.

Sorting though this madness,
eventually it was found the process for writing the frequency register
is as follows.
First,
modify the control register to a known value so that
the inactive register may be written and
the method of writing the frequency register is set to fine.
Fine frequency modification means both MSB and LSB of 
the frequency register can be modified.
Second,
Preform two consecutive 16 bit writes to the Minigen with
the first bits addressing the frequency register, and
the remaining 14 bits containing either the LSB or MSB of the requested frequency.
Third,
Preform a final write to the control register to 
make the frequency register which has just been written
the active register.

The other problem which needs to be solved
is, of course, what values need to be written to the frequency register.
That is we need to convert the decimal value
given to a binary string to be written.
This is accomplished by first dividing by
the minimum step size of the Minigen.
The resulting value gives the number of steps necessary
to achieve the value wanted.
The number which is written the frequency register
is the number of steps.
Finally,
this step value is converted and sent in the order,
MSB than LSB.

\subsection{Controlling Voltage}
\subsubsection{Programmable Gain Amplifier(PGA)}
The method of interaction with the PGA
is though three GPIO pins which encode
a binary number indicating the desired gain.
The software written for the PGA than
has two objectives.
First,
the gain of each stage must be computed.
Second,
the gain of the PGA needs to be modified.

% explain how we choose the value to set the pga
In order to compute the gain of each amplifier,
two pieces of information are needed.
What is the gain of the amplifier in this stage and
what is the requested voltage.
The gain of the amplifier is know at design time and
the requested voltage is gained through user interactions
with the web interface.
Once these this information is known,
the problem reduces to one similar to
counting change.

In the counting change problem,
a person is trying to create 
a monetary value with the fewest number
of coins possible.
This problem is solved by
using as many of the biggest value coin as
possible without going over, then
using as many of the second biggest value coin as
possible without going over, ect.
In this example,
the coins are analogous to the gains of the
amplifiers in each stage of the circuit while
the monetary is analogous to the requested voltage.

The approach used in our implementation
is similar to that of the counting change problem.
In order to find the again of a PGA in a given stage,
we compute how many of that stage's amplifier gain
could fit in the overall requested voltage.
All stages conform to the following equation:
%
\begin{gather*}
A_{PGA} = floor(\frac{RV}{G_{AMP}})
\end{gather*}
%
where $A_{PGA} =$ gain of pga,\\
$RV =$ requested voltage remaining after voltage allocated 
to previous stages has been removed,\\
and $G_{AMP}$ is gain of amplifier in series with the PGA.

% explain how we modify the value of the pga
% discuss the problem of running things as root under apache webserver
Modification of PGA gain requires
the toggling of GPIO pins on the Raspberry Pi.
The pins should be set to a binary
value equal to the requested gain.
A Python object utilizing RPi.GPIO
was created.
This script preforms the
necessary mapping of gain value to GPIO pins and
modifies the value of GPIO pins accordingly, but
there is a problem.

Root access is required to modify the values of
the GPIO pins, and the Apache 2 web server
protects against cgi-bin scripts executing commands as root.
Our solution is to call a bash script with the arguments
necessary for the Python object to set GPIO pins to
a specified gain.
The intermediary bash script works by
\textit{echo}ing a short python program and
piping the output of this \textit{echo} command to
the input of \textit{sudo python}
This circumvents apache's protection
while still allowing the use of
Python.

\section{Cost Considerations}
The monetary cost of this project is fairly low. 
The precise costs of components in the future are unknown, but
a table 
of current prices has been provided
along with the necessary quantity of each component.
The projected cost of op-amps and other electronic components is minimal. 
The largest expenditure of the project is
the purchase of the 
Raspberry Pi 2 and 
Minigen Function Generator.
Other necessary components are a micro SD card,
resistors, capacitors, and op amps.

% table of costs
In the following table,
costs for capacitors and resistors are computed at .1 dollars each.
\begin{center}
    \begin{tabularx}{0.4\textwidth}{|X|X|X|X|}
        \hline

        \textbf{Item} &
        \textbf{Part Number} &
        \textbf{Quantity} &
        \textbf{Price(\$)} \\
        \hline

        \textbf{Raspberry Pi 3 Kit} &
        \textbf{-} &
        \textbf{1} &
        \textbf{49.99} \\
        \hline

        \textbf{Micro SD card} &
        \textbf{-} &
        \textbf{1} &
        \textbf{9.99} \\
        \hline

        \textbf{Minigen Function Generator} &
        \textbf{AD9837} &
        \textbf{1} &
        \textbf{29.95} \\
        \hline

        \textbf{Resistor} &
        \textbf{10$K$ Ohm} &
        \textbf{1} &
        \textbf{0.10} \\
        \hline

        \textbf{Resistor} &
        \textbf{1$K$ Ohm } &
        \textbf{1} &
        \textbf{0.10} \\
        \hline

        \textbf{Resistor} &
        \textbf{330 Ohm } &
        \textbf{1} &
        \textbf{0.10} \\
        \hline

        \textbf{Resistor} &
        \textbf{220 Ohm} &
        \textbf{3} &
        \textbf{0.30} \\
        \hline

        \textbf{Capacitor} &
        \textbf{1$uF$ } &
        \textbf{2} &
        \textbf{0.20} \\
        \hline

        \textbf{Capacitor} &
        \textbf{.1$uF$} &
        \textbf{11} &
        \textbf{1.10} \\
        \hline

        \textbf{Capacitor} &
        \textbf{.1$nF$} &
        \textbf{6} &
        \textbf{0.60} \\
        \hline

        \textbf{Op Amps} &
        \textbf{OPA552} &
        \textbf{3} &
        \textbf{4.41} \\
        \hline

        \textbf{PGA} &
        \textbf{pga 6910-3} &
        \textbf{2} &
        \textbf{8.00} \\
        \hline

        \hline
        \textbf{Total} &
        \textbf{-} &
        \textbf{-} &
        \textbf{104.84} \\

        \hline
    \end{tabularx}
\end{center}

\section{Testing}
In order to discuss testing in a more clear way
it is useful to define a number of steps
in the testing process.
Each of these steps can than be developed for
each of the various components to the project.
%
The flow of the testing process
involved an iterative process of:
\begin{enumerate}
\item Theorize a design
\item Acquire necessary components
    \begin{itemize}
    \item knowledge
    \item hardware components
    \end{itemize}
\item Implement design
\item Understand problems
\item Return to step 1
\end{enumerate}
%
It is important to recognize that many
of these steps may be different for different components.
A program written to be run by the web server
will inevitably have different testing requirements from
a new integrated circuit component.

% elaborate on each step of the process 
% describe how each component is affected at each step
% discuss the goal of each phase
\subsection{Testing Process}
Each phase of the testing process poses unique challenges.
Here are presented some of those challenges and
how each phase related to specific aspects of this project.
Importantly, the time it takes to complete a 
testing cycle varies drastically.
Hardware components, for instance, take far longer to test
as they must be constructed on a breadboard in order that 
measurements may be taken with lab equipment.
%
The length of the testing cycle is 
directly proportional to the extent to
which a component may be tested.
%
For objects with long testing cycles,
much more time is spent in the 
theorizing a design phase compared to
objects with shorter testing cycles.

\subsubsection{Theorize a design}
In this phase of development,
the goal is to determine:
\begin{itemize}
\item A design which \emph{should} work
\item What knowledge is needed to complete an implementation
\item What physical components will be necessary
\end{itemize}

Often times it is wise to determine the above for
multiple potential solutions.
The time necessary to implement each solution
can then be estimated and weighed against
the potential for success with such a design.

Which design is chosen for implementation is
some combination of the estimated time and
potential for success.
The decision to abandon a design is often
due to a change in one of these factors.
This change can occur either
in the current design or
in one of the alternative designs.
An example which might motivate abandonment of a 
particular solution might be
the finding that a certain hardware component
contained in the current design is incapable of 
working at a high enough frequency to
produce the overall output.

% cover hardware and software components and differances in this phase between them
While the theory of testing hardware and software is similar,
in practice these activities can be very different.
In this project, however,
they became somewhat similar 
due to the fact that program code is written in order to 
interact with hardware components.
In both cases,
the physical output of either GPIO pins on the Raspberry Pi
or output of a circuit component must be view on
an oscilloscope.

\subsubsection{Acquire necessary components}
The goal of this phase is self-explanatory.
The necessary components must be acquired.
While the goal may be clear and simple;
it may not be easy.
The term acquisition may refer to  physical hardware,
but it also refers to the knowledge necessary to implement
a given system.
Every potential implementation has a knowledge component.
Even if the knowledge is already known by the group as a whole,
it may be useful to consolidate the information.

Fundamentally this process tries to answer the question,
"What do I need to know in order to create x result".
Where x is the goal of the component as a whole, or
x is a subgoal which is thought to contribute to 
the overall goal of the component.
This phase of testing
sets the theorized design against existing knowledge.
Often times it is necessary to return to the 
theorizing phase and reconstitute the design
given new information which has been acquired.

% illustrate the differences between acquiring hardware and software components
Acquiring components phase has analogs in both hardware and software domains.
In the software domain,
acquiring components consists of
software packages, such a Apache 2, or
knowledge assets necessary to complete a program.
In the case of this project,
we needed to learn how to use and configure apache,
write Python code on the Raspberry Pi,
use py-spi in order to communicate with the Minigen, and
use GPIO library on Raspberry Pi to communicate with the PGA components.

Compare this to the hardware domain where
the acquisition of components is fairly straightforward.
Components are necessary to be purchased.
This process takes much longer when compared
to downloading a software package.
Thus, it is useful, wise, and resource efficient to
spend much more time in the theorizing a design phase.
Having an increased degree of certainty that 
a given component will preform as expected
alleviates the time and money required to determine 
that a component will not work empirically.
This certainty can be developed though simulations, or
developing a mathematical description of the output of a design.

\subsubsection{Implement design}
Of all the phases, 
this phase constitutes the largest investment.
The majority of time spent on the project is
used to implement a design.
The goal of this phase is both obvious
and complex.

An increased degree of efficiency may be achieved by
constructing a minimal working example(MWE).
The benefit in doing this is twofold.
First, a MWE is often easier to construct compared to
a version which is constructed into the other
components of the project.
Second, because constructing a MWE requires that
this sample implementation not be integrated into
the rest of the project,
issues which arise from the interplay between devices are not present.
This helps to isolate issues which are a product
of the specific aspect of the project which is being implemented.

% discuss differences between hardware and software implementations
Implementing designs in hardware is significantly different compared to software.
Hardware designs must be constructed with physical components on a breadboard.
These components must be connected and measured with lab equipment
in order to determine if the components are having the correct output.
All the steps in this process take time.
Other issues also exist due to the physical nature of 
hardware components.
A component might be partially burned out and providing output
which is not correct, but still proving output.
The difficulty with this is that the component appears
the same as it would if it were connected incorrectly.
For these reasons,
the Implementing a design phase 
consumes many more resources in the time and economic
domains compared to software implementations.

\subsubsection{Understand problems}
After implementation of the design is complete,
it must be determined whether or not the device functions
as expected.
Often times this means looking at the input and
output waveforms on an oscilloscope for hardware or
observing the change in state of the GPIO pins for
testing software.
Once a problem has been identified,
the source of the problem must be located.

To clarify the above point, consider 
an example of a problem which might be observed is
a difference in amplitude of the output waveform
compared to what was expected.
The problem might be any component which is
connected to the measured point.
This includes components which are connected
via other components.

Often times to identify the source of an issue,
it is necessary to understand what should be
the input and output of all components in the circuit.
Testing the inputs and outputs of each component in turn
moving away from the originally observed wrong output can
help to find where the origin of the problem occurred.
Perhaps the component which gives input the component
previous the the component with the observed problem
is connected incorrectly.
This could cause the output of all future components to become incorrect.

A similarity between debugging code and
finding issues in hardware implementations is
the effect of mistakes.
The way a mistake propagates though a
program is similar to the way mistakes
propagate though hardware implementations.
All events after the first error are
often a result of the first error.
There fore these events are also in error.
Often times a good debugging strategy is
to approach solving the first error.
The benefit in doing this is that future errors
might be solved indirectly.

\subsubsection{Return to step 1}
Many times it is found that designs would not work
and thus this process is reset to the beginning.
This step can be disheartening, but
it is wholly necessary.
Emotions of anguish may cloud a person's judgment
causing them to stick with a particular implementation
for far longer than what is necessary to determine 
better solutions exist.
Developing a control over these emotions
yields decisions which reduce the time
taken to complete a project and
often produce better results.

Much wisdom is needed to be able to objectively 
evaluate one's current situation and determine 
whether it is advisable to
continue down the current path or whether
The new information gathered in the "understanding problems" phase
warrants the construction of a new design 
or significant portion of design.
Often times this can be reduced to answering the following question honestly,
"Given what is now known,
is it wise to invest in the current course of action, or
is there something else which might have an improved probability of success"

% discuss the difficulties with this with respect to hardware components
In software,
returning to theorizing a consumes far fewer resources compared
to redesigning a hardware implementation.
In software,
new packages may be downloaded nearly instantaneously.
Compare this with hardware where new components must
be chosen, bought, and shipped.
The need to redesign can be expensive and time consuming, but
often times it is wise to do if the current design is not working as expected
to such an extent that another design would be a smarter investment.

\subsection{Testing Results}
Testing occurred in an iterative process
as described above throughout the semester.
Each time a new design would be reached,
the steps above were used to uncover what
the issues were, 
how to solve them, and
whether it was wise to solve them at all.
The alternative to solving current issues is
establishing a new design.

A typical testing environment includes:
\begin{itemize}
\item Oscilloscope
\item Raspberry Pi
  \begin{itemize}
  \item Connected for monitor for web interface access
  \item Connected to circuit to control Minigen, PGA's
  \end{itemize}
\item Multiple breadboards
  \begin{itemize}
  \item Minigen Function Generator
  \item PGA's
  \item Summing amplifier
  \end{itemize}
\end{itemize}

\subsubsection{Known Issues}
Below are some of the issues found
through the course of our testing
which have not been resolved.
These issues are fairly minor compared
to the overall functionality.

The current solution has some noteworthy issues
which need to be addressed.
Issues are defined as unintended issues of unknown origin.
Possible reasons for each of the issues are discussed as
well as the accommodations made in this implementation to lessen their impact.
Potential solutions are also mentioned.

\textbf{B23}\\
In the current prototype,
there is an ongoing issue with the Minigen Function Generator.
This device works as expected in most cases.
The exception occurs when bit 23 of either frequency register
is set high.
This case will cause the Minigen device to produce a $4Mhz$ sine wave.
There is potential that the specific Minigen device used 
is responsible for this bug.
Further testing is required.

The solution currently implemented is
to detect conditions which will cause the error
and avert these situations problematically.
Whenever bit 23 is set to high in a frequency register write,
the current implementation sets bit 23 to low
and sets all less significant bits to high.

\textbf{Current Draw from Raspberry Pi}\\
Throughout the course of our testing,
the Raspberry Pi turned off at random several times.
After this happened in a few different scenarios,
it was determined that this problem
did occur when an active display adapter was used and
did not happen when a passive adapter was used 
to connect the display.
The difference between these adapter types is,
active adapters require power while,
passive adapters do not.
The question becomes,
"what about requiring more power from the Raspberry Pi creates issues?".

After doing some research on the Internet,
we found several sources which describe 
a relevant protection mechanism of the Raspberry Pi.
When there is more power demanded from the Pi than
the Pi can supply then
the Raspberry Pi will turn off to protect itself.
This is a useful mechanism and must have 
saved our test Raspberry Pi a dozen times.

The amount of power this implementation
requires from the Raspberry Pi is somewhat high.
The $3.3V$ output rails are used to power the
Minigen Function Generator, and
other GPIO pins are also used for interacting
with the PGA's.
Given these conditions,
it is not surprising that the Rasberry Pi 
protection mechanism was necessary
when additional power was required
through the Pi's HDMI port.

\textbf{Amplifier Circuit}\\
Currently,
the amplifier circuit is not capable of reaching 
the maximum frequency or voltage requirement.
Currently the maximum achievable frequency 
at which the voltage gain of the circuit has
not dropped by more than $3db$ from it's intended value is
around $800Khz$.
In other words the $-3db$ frequency of this circuit is $800Khz$.
The issue which prevented reaching a frequency of $1Mhz$ was
an insufficient gain bandwidth product of our chosen op-amp.

The maximum voltage can also not be reached.
This is due to an insufficient slew rate
of the OPA552, the current op-amp.
This op-amp is unable to change voltage fast enough
to output large amplitude waves at high frequency.

\subsubsection{Possible Solutions}
In the case of 
the current draw from the Raspberry Pi problem and
the B23 bug,
it is clear how the problem might be solved.
However, in the case of  the amplifier circuit
the solution is non-obvious.
Possible remedies could range anywhere from a complete redesign
to the purchase of additional components.
The later option is more resource efficient 
if it is available.
There much more expensive op-amp around \$150 has
the necessary specifications
to fulfill the project requirements.
The part number of this op-amp is
598-1449-ND.
Replacing the OPA552, the current op-amp,
with this one would, in theory,
allow the design to meet all the frequency and voltage requirements.

% compare what has been accomplished to the project description
% note the dependencies between them
% detail each difference and highlight why it happened
% conclude with the final state of the project
\section{Concluding Remarks}
At the onset of this project,
there was a lot of rapid success.
During the first semester,
much of the scripts which
interact with the circuit from
the Raspberry Pi were written.
We were able to modify the frequency 
and communicate with the PGA's by 
the end of the first semester.
The work on the amplification portion 
of the project took significantly more time.
Most of this additional time expense came
as a direct result of 
the number of problems encountered.

In addition to the implementation struggles
in the second semester of this design experience
came a shortage of manpower.
One group member had to drop out of school for financial reasons.
This was especially difficult to 
deal with as the number of
people on the project was already
fewer compared to the number
called for in the project description.
This project originally specified
that there should be three computer
engineers and three electrical engineers
working on the project.
Reality instead afforded the group
assigned to this project four computer
engineers.
This eventually became
three computer engineers.

Being computer engineers,
our skill set lies outside the realm
of complicated circuits.
Our lack of experience with building and testing
circuits designs
manifested itself in the struggles constructing
the multi-stage amplifier circuit.
While the general lack of 
expertise with the circuit components
of the project hampered our group
significantly in the completion of the project,
it was a very good learning experience.
Often times the most difficult situations
inspire the most growth.

The final state of the project is
very close the the design specifications.
The state does deviate in a few key aspects,
but overall the viability of the design
has been proven.
If the more expensive op-amps would have
been purchased,
all of the design parameters would have
been met, at least in theory.
In other words,
the limitations of the current implementation
are due to op-amps with insufficient
slew rate and
gain-bandwidth product.

Many of the issues which arose in this
project came from the amplifier circuit.
There were many design iterations
where a new component would get introduced.
This component would always cause some problem or
have an adverse effect in some way.
Eventually the component would be removed,
or the design would be modified to
accommodate the problems associated with the new component.
Sometimes the design would even be reverted to
a previous configuration.
Progress on  the amplifier circuit came in
small increments.
Over time,
these increments summed to the nearly-functioning
implementation at the conclusion of this project.

% go to next page
\newpage
%\pagebreak
\appendix

\section{Operation Manual}
\subsection{Quick Setup}
Here are listed the setup steps
as succinctly as possible.
If more detail is required,
the below Setup section covers
each step in more detail.
\begin{enumerate}
\item sudo raspi-config
    \begin{enumerate}
    \item expand file system
    \item enable SPI in advanced options
    \item (optional) enable SSH in advanced options
    \item Finish > Reboot
    \end{enumerate}

\item Acquire Project Codes
    \begin{enumerate}
    \item git clone http://github.com/timdee/cpre492
    \end{enumerate}

\item Modify apache2 document directory
    \begin{enumerate}
    \item sudo rm -r /var/www
    \item sudo ln -s /home/pi/cpre492/www /var/www
    \end{enumerate}

\item Enable cgi-bin
    \begin{enumerate}
    \item sudo a2enmod cgi
    \end{enumerate}

\item Modify cgi-bin Directory
    \begin{enumerate}
    \item sudo rm -r cgi-bin /usr/lib/cgi-bin
    \item sudo ln -s /home/pi/cpre492/cgi-bin /usr/lib/cgi-bin
    \end{enumerate}

\item Modify apache to run as user pi
    \begin{enumerate}
    \item sudo nano /etc/apache2/envvars
    \item export APACHE\_RUN\_USER=pi
    \item export APACHE\_RUN\_GROUP=pi
    \end{enumerate}
\item sudo reboot
\end{enumerate}

\subsection{Setup}
This section details the materials needed and
how to set them up.
This section assumes you have nothing
other than the
circuit to connect to the Raspberry Pi and
the controlling code which needs to be placed on
the Raspberry Pi.

Setup includes all necessary information
for the Raspberry Pi configuration.
Such information is provided
for the purpose of understanding 
how the system has been established
in hopes that it might be easier to modify or
change in the future.

\textbf{Steps:}
\begin{enumerate}
\item Purchase a Raspberry Pi
    \begin{enumerate}
    \item micro SD card
    \item micro USB power cord
    \item (optional) USB wifi adapter
    \item (optional) Ethernet cable
    \end{enumerate}
\item Install Rasbian Linux Operating System on Raspberry Pi
\item Configure Installation
\item Place circuit controlling software on the Raspberry Pi
\item Install software packages on Raspberry Pi
    \begin{enumerate}
    \item Apache 2 Web Server
    \item RPi.GPIO
    \item spidev
    \end{enumerate}
\item Modify configuration files on the Raspberry Pi
\item Verify configuration
\end{enumerate}

% explain each of the steps
\subsubsection{Purchase a Raspberry Pi}
The object of this step is self-explanatory, however,
there are some useful points to note when purchasing
a Raspberry Pi.
Often times the Raspberry Pi is not sold with any accessories.
This means a few additional items must be purchased
in order run and use the device.
The additional items which must be purchased are:
a power cord and
micro SD card.

\subsubsection{Install Rasbian Linux Operating System on Raspberry Pi}
It is recommended that Rasbian Linux distribution is used
as the operating system for the Raspberry Pi.
This system will work with other operating systems,
but Rasbian has many of the necessary libraries available
at install.
In addition, Rasbian is optimized for the hardware of the Raspberry Pi.
Other distributions may run slower, or
not have all of the correct drivers at installation.
There are no current factors which would motivate the
use of another distribution.

The latest version of Rasbian can be downloaded from:
\url{https://www.raspberrypi.org/}

This website also has a lot of good documentation for
the Raspberry Pi.
It can be a useful resource for troubleshooting issues.
For this purpose,
there are many guides provided.

One such guide describes how to install Rasbian to the Raspberry Pi.
This guide can be viewed here:
\url{https://www.raspberrypi.org/learning/noobs-install/}

The previous guide describes the process
of installing the operating system with NOOBS.
Another way to install Rasbian could be as follows:
\begin{enumerate}
\item Acquire a micro SD card 
\item Download Rasbian Linux Operating System
\item Acquire a program capable of writing an image
    to a micro SD card on a computer with a micro SD card interface
\item Write the image to the micro SD card
\item Place the micro SD card in the Raspberry Pi
\item Power on the Raspberry Pi and complete configuration
\end{enumerate}

In general,
the processes can be summarized as 
writing an image of the Rasbian Linux Operating System to
an SD card.
While this brief description does not capture the nuances
associated with installation,
it is enough to understand the correct
course of action.

\textbf{Interfacing With the Pi}
% talk about how to connect the pi to a computer and interact with it
% recommend that ssh be setup to control the pi remotely
During the setup process,
there will be need to interact with the Raspberry Pi.
This can be done in a couple ways.
One way to interface with the Pi is to use
it directly.
Direct use can be done by using the HDMI output
on the Raspberry Pi to input to a monitor.
A keyboard an mouse may also be inserted into
the USB ports on the Raspberry Pi.
Interactions using this method are similar to 
using a standard desktop computer.

Another useful way to interact with the Raspberry Pi
might be to use the secure shell program (SSH).
SSH allows remote communication with the Pi as
long as it is on the same network.
An example of how this might work is this,
plug the power cord and Ethernet cable into
the Raspberry Pi,
after the Pi has booted fully,
another computer runs the following command.
\begin{lstlisting}
ssh [raspberry pi ip address]
\end{lstlisting}
After running this command,
the user will be present with a login prompt.
After login is complete,
a command prompt will be displayed.
This will enable the user to interact with the pi
as if the interaction was direct while still
being connected to the Pi over the network.

\subsubsection{Configure Installation}
% discuss raspi config
It is necessary to configure the installation
for two reasons.
First, when the installation material was
written to the installation medium,
it's partition was only exactly the size it needed to be in order to 
preform the install.
In order to put additional files on the system,
the file system must be expanded.
Second, this project utilizes the SPI interface
on the Raspberry Pi.
In order to use this interface,
SPI module needs to be enabled.

Thankfully Rasbian Operating system
provides an easy setup script for preforming 
both of these actions.
To run this setup script in order to configure the
installation,
the following command can be executed as user Pi.

\begin{lstlisting}
[pi@raspberrypi ~]$ sudo raspi-config
\end{lstlisting}

The following screen should present itself
after running the above command.

\begin{center}
\includegraphics[width=0.43\textwidth,keepaspectratio]{raspi_config.png}
\end{center}

Follow the prompts in order to expand the file system.
To enable SPI, it is necessary to first
select "advanced options" followed by "enable SPI".
Optionally, SSH may be enable.
Enabling this option will cause an SSH server
to be run on the Pi after the next reboot. 
Make sure to reboot;
acquiring program code in the next step will require
that the file system has been expanded.

\subsubsection{Place circuit controlling software on the Raspberry Pi}
In order to acquire the project code constructed to 
allow the Raspberry Pi to control the rest of the circuit,
the following command may be used.
This command should be run in user pi's home directory, "/home/pi".
The rest of the guide assumes this location for the files.
If this is not the chosen location on the
Raspberry Pi,
simply use the chosen location in place of "/home/pi".

\begin{lstlisting}
git clone http://github.com/timdee/cpre492
\end{lstlisting}

This command will download the code from
a github repository.
There should now be a folder "/home/pi/cpre492" with
all of the code and documents present.
If an error occurs which indicates there is no more disk space,
then it is likely that rebooting the Raspberry Pi will fix this issue.

\subsubsection{Install software packages on Raspberry Pi}
In order for the software written to
control the circuit to preform it's task,
a few additional software packages must be installed.
These packages are necessary for:
running the web server
and modifying the values of the GPIO pins.
The names of the packages are as follows

\begin{itemize}
\item apache2
\item spidev
\item RPi.GPIO
\end{itemize}

In order to install the packages,
it is necessary to run the following command:

\begin{lstlisting}
sudo apt-get install [package name] -y
\end{lstlisting}

The above command will install the desired package.
This may be done for apache as follows:

\begin{lstlisting}
sudo apt-get apache2 -y
\end{lstlisting}

Note, RPi.GPIO is usually installed with the installation
medium.
If it is not,
the process for installing RPi.GPIO is slightly different.
The package must first be downloaded from:
\url{https://pypi.python.org/pypi/RPi.GPIO}

After the package has been downloaded,
it needs to be extracted and moved to the
the cgi-bin directory of the apache web server.
Such a process might look like the following:

\begin{lstlisting}
[pi@raspberrypi ~]$ cd Downloads
[pi@raspberrypi Downloads]$ tar -zxvf RPi.GPIO.tar.gz
[pi@raspberrypi Downloads]$ mv RPi.GPIO ~/apache2/path/cgi-bin/
\end{lstlisting}

The process outlined above may not be necessary if
RPi.GPIO is included in the provided softwares.
If this is the case, then
the above procedure may still be useful for updating
the library.
This may be necessary to fix unforeseen, obscure bugs.

A possibly old version of spidev is included with the provided codes.
If an upgrade is required,
the process for doing so is similar to RPi.GPIO process.
The only difference being the package
will be downloaded from a different place.

\subsubsection{Modify configuration files on the Raspberry Pi}
The configuration files which need to be modified are
related to Apache 2 web server.
The files which need to be modified for the following reasons.
First, the apache user (www-data) does not have the permissions necessary
to run some of the library functionalities.
One solution to this issues is to run apache as 
a user which does have permissions.
In this case,
we choose to use the default user, pi for this purpose.

Second, the apache package needs to be told where
the files for the web server have been placed,
otherwise apache will load the default configuration
which is not what is wanted.
This is another simple modification to one of the configuration files
There is, however, an alternative to modifying the configuration of the server
in specifying the directory where the web server files are located.
The alternative is to create symbolic links at the default locations 
loaded by the web server.
This option is chosen for compatibility purposes.
Taking the former approach assumes the configuration files will
be setup the same with every iteration of apache2.
This is not always the case.

\textbf{Running Apache as User pi}
To change the run user for apache,
run the following command.
\begin{lstlisting}
[pi@raspberrypi ~]$ cd Downloads
\end{lstlisting}
This will initiate a command-line
text editor which should be used to 
modify the APACHE\_RUN\_USER and APACHE\_RUN\_GROUP
to be the following:
\begin{lstlisting}
APACHE_RUN_USER = pi
APACHE_RUN_GROUP = pi
\end{lstlisting}

\textbf{Modifying Web Site Files Location}
There are two relevant directories,
\textit{www} and \textit{cgi-bin}.
The method chosen to modify these
directories are though the creation of
symbolic links at the default file locations.
This may be accomplished though the following command sequence:

\begin{lstlisting}
[pi@raspberrypi ~]$ sudo rm -r /var/www
[pi@raspberrypi ~]$ sudo ln -s /home/pi/cpre492/www /var/www 
[pi@raspberrypi ~]$ sudo rm -r /usr/lib/cgi-bin
[pi@raspberrypi ~]$ sudo ln -s /home/pi/cpre492/cgi-bin /usr/lib/cgi-bin 
\end{lstlisting}

\subsubsection{Verify Configuration}
In order to verify that the configuration
is working properly,
open a web browser,
type localhost in the navigation bar, and
press enter.
If a web interface used to update
voltage and frequency values is loaded then
the configuration is correct.

\subsection{Demo}
This section details the process
by which a device which has already
been setup may be showcased.
An example use of the system might be as follows.
Connect the output of the circuit to the pair
of capacitive plates which will drive 
the dielectrophoresis experiment.
Once connected,
Connect to the raspberry pi over
the local area network from
any computer on the network and
use the interface to modify the
voltage and frequency output of the circuit.

\textbf{Steps:}
\begin{enumerate}
\item{Power on the Raspberry Pi}
\item{Connect the Raspberry Pi to the network}
\item{The output of the circuit should connect to capacitive plates used for dielectrophoresis}
\item{Acquire the IP address of the Raspberry Pi}
\item{Enter the IP address in the navigation bar of a web browser}
\item{Input the desired voltage and frequency values and click update}
\item{The output of the circuit can be seen to change to the desired values}
\end{enumerate}

% discuss each step
% pictues of each step
\subsubsection{Power on the Raspberry Pi}
In order to power on the Raspberry Pi,
It must be plugged into a wall output.
The power adapter for this device is
the same as any micro USB smart phone adapter.
Once plugged in,
The Raspberry Pi will power up automatically.

If the Raspberry Pi is connected to a monitor,
there should be many lines of output to the screen.
The powering on process takes about a minute,
so be patient.
After startup has completed,
one of two scenarios will be the case.
Scenario 1, the Pi boots to a graphical
user interface.
If this is the case,
then continue with the succeeding steps.

If however, there is a command line displayed instead,
this is scenario 2.
In scenario 2 it is necessary to log into the pi.
This may be done with the default user name and password listed below.
\begin{lstlisting}
# username: pi
# password: raspberry
\end{lstlisting}

\subsubsection{Connect the Raspberry Pi to the network}
Connecting the Raspberry Pi to the network may
be done in a couple of way:
through the Ethernet port on the Raspberry Pi, or
through a wireless network adapter connected to
one of the Raspberry Pi's USB ports.
Either method of connection will allow
any computer on the local network to 
connect to the web server running on the Raspberry Pi.

\subsubsection{The output of the circuit should connect to capacitive plates used for dielectrophoresis}
Ensure all of the outputs to the circuit are connected properly.
Preforming this step incorrectly can cause damage to the equipment.

\subsubsection{Acquire the IP address of the Raspberry Pi}
Finding the Raspberry pi on the network can be somewhat tricky.
The Raspberry Pi has a display output on board.
If access to this display is available,
a keyboard may be connected to the pi in order to
interact with it.

To acquire the IP address of the Raspberry Pi,
login and run the 'hostname' command with arguments '-i'.
This command is depicted below.
\begin{lstlisting}
# hostname -i
\end{lstlisting}
The output of this command will the the IP address of
the Raspberry Pi on the network.
Note the raspberry pi may be configured to 
login automatically at start up.
This depends on the installation medium.

There are other ways to acquire the IP address
which involve scanning the network from
another computer on the network.
Another way would be to configure a static IP address
for the Raspberry Pi.

Configuring a static IP can be done in a few ways.
One way to accomplish this is
to modify the router setup to assign the Raspberry PI a specific IP.
Another method is to configure the PI to request a specific IP address.

\subsubsection{Enter the IP address in the navigation bar of a web browser}
On any computer connected to the same network as the Raspberry Pi,
open a web browser.
In the navigation bar of this browser,
enter the IP address retrieved from the 'hostname' utility.
In the below example,
The web browser is instructed to navigate to localhost.
This can be used to access a web server running on the current machine.
If the goal is to navigate to a web server running on a different
machine, thee
entering the IP address of this machine in place of localhost will
accomplish this goal.

\begin{center}
\includegraphics[width=0.43\textwidth,keepaspectratio]{localhost_navigation.png}
\end{center}

\subsubsection{Input the desired voltage and frequency values and click update}
The web interface contains fields to input the desired frequency and voltage values.
Enter these values and click the 'update' button.
Doing so will cause scripts to Run on the Raspberry Pi that
set the values of the GPIO pins in such a way that the output is produced
by the circuit.
There is also a Radio Button group which will allow the 
output waveform to be modified among triangle, square, and sine.

\begin{center}
\includegraphics[width=0.43\textwidth,keepaspectratio]{web_interface_updating_values.png}
\end{center}

\subsubsection{The output of the circuit can be seen to change to the desired values}
After the 'update' button is pressed,
the output of the circuit will be modified
to the closest possible values.
The voltage and frequency resolution are limited,
thus the output may not be exactly the value entered.

After update is pressed,
the web interface will be re-displayed.
This will allow the modification of voltage and frequency again.

\newpage
\section{Initial Designs}
This section covers the designs that have been tried
throughout the course of the project. 
These were problems with each of these designs
which motivated a change from that design to
a more resent design.
Designs are presented in roughly chronological order in each section
to perhaps make it more clear what motivated
a particular design choice.
Each component underwent various adaptations 
over the duration of the project.

In an introductory economics class,
it is common that students are taught about sunk costs.
Sunk costs refer to those costs which
have already been incurred and
cannot be recovered.
These classes teach that suck costs should not
be considered in making future investments.
In other words,
one should not ask themselves the extent of 
current investment down a particular path.
Rather, one should ask,
given what is known now,
which investment is more intelligent.

While economics classes teach about sunk costs in
the context of monetary investment,
the same logic may be applied to other domains.
In the case of this project,
the investment capital is time and energy.
Regardless of how much energy has been invested
in a particular design,
it is necessary to evaluate alternatives to that design.
If these alternatives than look better
given what is known about both designs
than the design should be modified accordingly
to fit the alternative design.

Throughout the course of this project,
several components needed to be redesigned.
Below is some mention of these designs and
the issues encountered which motivated deviation from them.

\subsection{Frequency Control}
The Raspberry pi is capable of producing square waves by turning the GPIO pins on and off rapidly. We can use this functionality to produce a wave of the frequency indicated by the user. The GPIO pins can also be used to set the voltage by communicating with the circuit how much the output waveform should be amplified. The downside to this approach is the analog circuit component will need to be more complex. The analog circuit needs to output a sine wave. With this approach we would need to integrate the square wave produced by the GPIO pin.

There exist alternatives to using the GPIO pins to generate a signal with a given frequency. We could instead use the GPIO pins on the raspberry pi to communicate with a small signal generator, such as \textit{sparkfun.com}‘s Minigen Function Generator. This would make programming the Raspberry pi more complex, but could lead to higher quality waveforms. Producing a sine wave using the Minigen signal generator is likely to to produce fewer distortions compared to integrating a square wave produced by the RPI’s GPIO pin twice. 

This design was scrapped due to the increased complexity of programming on
the Raspberry pi in conjunction with
concerns about the maximum amount of current which could be output
by the Raspberry Pi.
These concerns in conjunction with the ease of SPI communications
with the Minigen drove the choice to use the Minigen to generate the
frequency of the output.

% what component was tried
% what were the issues with the component which motivated a change
\subsection{Voltage Control}
\subsubsection{Digital Potentiometer}
The output of the digital potentiometer has 128 steps. This Translates into our ability to set 128 different gains on our amplifier. We will need multiple stages of amplifier to go between 1 and 60 Vpp. The most prominent reason for this is due to the gain bandwidth of the op-amps. We will not be able to have a large gain while still producing a frequency of 1Mhz.

One problem we foresee with the digital potentiometer is that it cannot handle a large amount of power. This may force us to come up with different amplifier configurations, or use the digital potentiometer in a different way. Another way we could possibly use this device is as an attenuator at the input to the amplifier.

Another problem which might arise with the digital potentiometer is the capacitance of the wiper. We don’t have any context for understanding how much this will affect the output signal. According to some preliminary calculations, we have determined that the capacitance will not present a large problem.
This design was replaced by a programmable gain amplifier.

\subsubsection{Transistor switch}
The overall voltage output by the amplifier circuit
varies between $1V_{pp}$ to $60V_{pp}$.
In our implementation,
this range is segmented into three parts of $20V_{pp}$ each.
Each of the three segments are input to a summing amp to
create up to $60V_{pp}$ overall.

A PGA is used for fine adjustment of one $20V_{pp}$ range while
the other two ranges are either $20V_{pp}$ or $0V_{pp}$.
In other words,
there ranges are turned on or off.

The original design for turning on and off the ranges
required that a BJT transistor switch circuit be used.
The intent was for this circuit to have either $20V_{pp}$ or $0V_{pp}$
depending on a GPIO pin from the Raspberry Pi.
This design did not work as intended.
Even when the transistors were off there was still current leakage.
This current leakage caused problems when input to the summing amplifier.
For this reason, the BJT transistor switch ciruits were replaced with solid state relays.

\subsubsection{Relay}
The proposed use for the relays was
similar to the to the transistor switch.
The advantage the relays have is the use
of an internal led to allow or disallow
current though the relay.
One way this might work is by
connecting a GPIO pin from the Raspberry Pi to
the led pin on the relay.
Setting this GPIO pin to high would then
cause the led to shine allowing the signal
from the Minigen to flow through the relay.

The overall voltage range,
$1V_{pp}$ to $60V_{pp}$,
is divided into three $20V_{pp}$ ranges.
The relay's have two states,
on and off,
which allow for moment between the ranges.
When on,
the input the the Amplifier circuit is amplified to $20V_{pp}$.
This $20V_{pp}$ signal is input to the summing amplifier.
There are two of these relay circuits used.
Turning them on or off allows the voltage range to be chosen.
These relay circuits are controlled by 
GPIO pins on the Raspberry Pi.

The problem which occurred with this solution
was that the relays were incapable of
operating at the desired frequency.
The relays began to have problems at only $25K_{hz}$.
Compare this to the required $1M_{hz}$ frequency, and
it is obvious that the relays are not a good solution.

\subsection{Amplification Stages}
The initial design for the amplification stages
utilized three stages.
Two of these stages were used to increase the voltage by a constant amount while
the third stage is used to adjust the voltage within the range.
This give the variability of one pga multiplied by the number of stages,
in this case three were used.

There are three $20V_{pp}$ voltage ranges.
Which range being acted in is chosen by the relay circuits.
Within a given range,
however,
a PGA is used to control the voltage output.
In our implementation,
a PGA has control over a $20V_{pp}$ range.
The PGA has 8 steps within this range.
This Device is controlled by 
the SPI interface on the Raspberry Pi.

The problem with this design which motivated change was
the switches used to increase the voltage
by $20V_{pp}$ would introduce noise into the signal.
Another issue with this design was that
it used the PGA's in a very limited way.
Theoretically, if all PGA steps were able to
be used for each step of the other PGA's
this gives $3^7 = 343$ steps.
This means we have reduced the number of possible
steps by a factor of $49$ in order to accomplish
this design; better implementations must exist.

\newpage
\section{Other Considerations}
An argument can be made that there
cannot be a truly accurate model of life.
Any such model with an infinite degree of accuracy
would need to contain the model of life within it.
And that model would then need to contain
the model of the model.
This is scenario is impossible and 
illustrates why it is necessary to develop
simplified models.

Every model is based in reality, but
the model is not reality.
Sometimes simplifications are made in
the construction of the model which mask
some of the issues which can arise if 
it turns out this simplification was
not valid in the use scenario.

The project description for this industry project
determined it was advisable for 
the group working on it to have three computer engineers and
three electrical engineers.
Instead, our original group consisted of four computer engineers.
After the first semester of this project,
one of our group members dropped leaving only three computer engineers.
As a group we were able to accomplish most of the goals for the project.
Especially the goals more central to the topics covered in the
undergraduate computer engineering work at Iowa State University.

The fundamental issue with the portions of the project
more suited to an electrical engineer is
our models are oversimplifications of 
the physical circuit components.
Being unable to model the circuit
accurately at the design phase led to
a lot of unnecessary implementation time.
Where this is a lot of experiential learning in
such a process there is also great expense in the time domain.
This coupled with a lack of advanced knowledge about
circuits in general led our group
the have a tough time with the circuits component.

% example of our model being too simple
One instance where our group's oversimplification of
components hampered progress was in the design of the
amplification portion of the circuit.
We originally intended that the amplification 
would happen in three stages.
The op-amp chosen to preform the amplification turned
out to only work for gains greater than 5 unless
capacitors were used to connect the inverting input and output to ground.
A capacitor also needed to be used in the feedback loop.
We need a gain slightly over unity,
thus the use of this is necessary.
These capacitors did indeed make the op-amp work at the gain we need, but
they have the adverse effect of turning the op-amp into a filter and
applying a phase shift the the output of the op-amp.

% useful information
This scenario presented us with a choice,
either abandon the current op-amp, or
try to design all the stages such that 
the cutoff frequency is greater than $1M_{hz}$
with a phase shift equal to the other stages.
Given that we couldn't find any other op-amps 
in our price range which met the slew-rate, bandwidth,
and voltage rail requirements of our project,
the later was chosen.
This made designing the stages significantly more difficult.
For this reason we decided to only use two stages as
this would be easier to match up precisely.
With three stages it would be very difficult to 
create a uniform phase shift among the stages.
This would make it difficult to produce a precise output voltage.

% even though we knew the goal it was hard to design
Even though the goal was known,
to design two amplifiers with different gains 
having equal phase shifts,
accomplishing this was not trivial for us.
Our group did not understand how to model this circuit.
Knowing this would allow us to change components in
order to modify the phase shift without changing the gain.
Eventually we found that if, in the feedback loop,
we increased the value of the resistor by the same
factor which we reduced the capacitor by we could
produce a gain given by $\frac{R_F}{R_{IN}}$
while maintaining a phase shift.

% example of a lack general circuits knowledge
Many issues throughout the semester arose 
due to general lack of knowledge about circuits.
One of the clearest examples of this is occurred
in the interactions among components.
We did no understand how to separate
components initially.
This led to scenarios where the input, output of 
two components could work perfectly, but 
when these components were connected in
series the output of the overall
circuit did not work as expected.

The lack of experience also manifested in
the amount of time it would take for 
us to debug "simple" circuit problems.
We would, for instance, see an odd
wave on the oscilloscope which might clearly
indicate there wasn't a common ground or 
that the power supply wasn't turned on (oops).
Not knowing this,
we would proceed to the next logical step,
staring at the circuit for exorbitant amounts of time
and checking all the connections.
Eventually we learned what certain types of
oscilloscope traces might imply about the problem, but
experience would have made this process much faster.

\end{multicols}

\newpage
\section{Code}
% bash scripts
\lstinputlisting[caption=Bash script used to evoke GPIO library]{../../cgi-bin/pga_calling_script.bash}

% python scripts
\lstinputlisting[caption=Update Website Script]{../../cgi-bin/update.py}
\lstinputlisting[caption=Update Voltage and Frequency Script]{../../cgi-bin/update_voltage_frequency.py}
%\lstinputlisting[caption=Voltage Control Script]{../../cgi-bin/voltageControl.py}
%\lstinputlisting[caption=Voltage Control Script]{../../cgi-bin/voltage_regulator.py}
\lstinputlisting[caption=Minigen Control Script]{../../cgi-bin/minigen.py}
\lstinputlisting[caption=PGA Control Script]{../../cgi-bin/pga.py}
\lstinputlisting[caption=Reset Script]{../../cgi-bin/reset.py}

% modify timeline
%\subsection{Project Timeline}
% Timeline in table format
%\begin{center}
 %   \begin{tabularx}{\textwidth}{|X|X|X|}
 %       \hline
 %       
 %       \textbf{Item} & 
%         \textbf{Completion Date} & 
%         \textbf{Description} \\
%         \hline

%         Project Plan & 
%         01 Oct. 2015 & 
%         \multicolumn{1}{|p{12cm}|}{\centering 
%         Create a project plan which specifies the pieces of the project.
%         } \\
%         \hline

%         Project Design & 
%         15 Oct. 2015 & 
%         \multicolumn{1}{|p{12cm}|}{\centering 
%         Complete a detailed design of each component of our project. Assign people to work on the various pieces of the project.
%         } \\
%         \hline

%         Design Web Interface & 
%         01 Nov. 2015 & 
%         \multicolumn{1}{|p{12cm}|}{\centering 
%         Design and build web interface.
%         Outline code for Communications with Minigen and Digital Potentiometers.
%         } \\
%         \hline

%         Hardware Communications and Design & 
%         15 Nov. 2015 & 
%         \multicolumn{1}{|p{12cm}|}{\centering 
%         Get communications working between Raspberry Pi, Minigen, and Digital Potentiometers.
%         } \\
%         \hline

%         Prototype Completion & 
%         01 Dec. 2015 & 
%         \multicolumn{1}{|p{12cm}|}{\centering 
%         Take final steps testing prototype. Device should be able to do everything in specification.
%         } \\
%         \hline

%         Senior Design I Presentation & 
%         15 Dec. 2015 & 
%         \multicolumn{1}{|p{12cm}|}{\centering 
%         Present a working prototype of our project.
%         } \\
%         \hline

%         Begin Experimentation Component & 
%         01 Jan. 2015 & 
%         \multicolumn{1}{|p{12cm}|}{\centering 
%         Begin working on Research component of the project.
%         } \\
%         \hline

%         Continue Experimentation & 
%         01 Feb. 2016 - 05 May. 2016 & 
%         \multicolumn{1}{|p{12cm}|}{\centering 
%         Use the project to perform research.
%         } \\
%         \hline
%     \end{tabularx}
% \end{center}

%\subsection{Graphical Comprehension Aides}
%\begin{figure}[!hbt]
%\begin{center}
%\includegraphics[width=1.0\textwidth,keepaspectratio]{491_web_interface_good.png}
%\end{center}
%\caption{Web Interface}
%\end{figure}

%\subsection{Code Listing - HTML}
%\lstinputlisting[caption=Main HTML Page]{../www/index.html}

%\bibliographystyle{unsrt}	% Order by citation
%\bibliography{report}

\end{document}


